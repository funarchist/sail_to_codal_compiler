
// combine all the i-type arithmetic operations

DEF_OPC(addi, "addi", ITYPE_ADDI)
DEF_OPC(slti, "slti", ITYPE_SLTI)
DEF_OPC(sltiu, "sltiu", ITYPE_SLTIU)
DEF_OPC(xori, "xori", ITYPE_XORI)
DEF_OPC(ori, "ori", ITYPE_ORI)
DEF_OPC(andi, "andi", ITYPE_ANDI)

set opc_itype_alu = opc_addi, opc_slti, opc_sltiu, opc_xori, opc_ori, opc_andi;

element i_itype_alu
{
    use opc_itype_alu as opc;
    use xpr_all as rs1, rd;
    use simm12 as simm;
    assembly { opc rd "," rs1 "," simm};
    binary { simm rs1 FUNC3(opc) rd OPCODE(opc)};

    semantics
    {
        uint32 src1, result;
        int32 immediate;

        src1 = rf_xpr_read(rs1);
        immediate = (int32) simm;

        switch (opc) {
            case ITYPE_ADDI:
                result = src1 + immediate;
                break;
            case ITYPE_SLTI:
                if ((int32)src1 < (int32)immediate) result = 1;
                else result = 0;
                break;
            case ITYPE_SLTIU:
                if ((uint32)src1 < ((uint32) (int32) immediate)) result = 1;
                else result = 0;
                break;
            case ITYPE_XORI:
                result = src1 ^ immediate;
                break;
            case ITYPE_ORI:
                result = src1 | immediate;
                break;
            case ITYPE_ANDI:
                result = src1 & immediate;
                break;
            default:
                result = 0;
//                eprintf("Default case: %d", opc);
                break;
        }

        rf_xpr_write(result, rd);

    };
};