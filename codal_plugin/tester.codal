/* Generated Codal ISA from Sail AST */
/* module: tester */
/* Generated from 80 JIB definitions */

/* Includes */


/* Codal Translation */
/* Generated Codal ISA from Sail AST */
#include "common_enums.hcodal"
#include "config.hcodal"
#include "utils.hcodal"

/* -------------------------------------------------------------------------------------------------
 *                              RISCV - instruction operands
 * -------------------------------------------------------------------------------------------------
 */

// -------------------------------------------------------------------------------------------------
// Register operand element
// -------------------------------------------------------------------------------------------------

// Elements with assembler and binary sections are used to describe instruction operands.
// Registers, immediate operands, conditional predicate and addressing modes are described.

// Register: zPC : bits
// Register: zx0 : bits
// Register: zx1 : bits
// Register: zx2 : bits
// Register: zx3 : bits
// Register: zx4 : bits
// Register: zx5 : bits
// Register: zx6 : bits
// Register: zx7 : bits
// Register: zx8 : bits
// Register: zx9 : bits
// Register: zx10 : bits
// Register: zx11 : bits
// Register: zx12 : bits
// Register: zx13 : bits
// Register: zx14 : bits
// Register: zx15 : bits
// Register: zx16 : bits
// Register: zx17 : bits
// Register: zx18 : bits
// Register: zx19 : bits
// Register: zx20 : bits
// Register: zx21 : bits
// Register: zx22 : bits
// Register: zx23 : bits
// Register: zx24 : bits
// Register: zx25 : bits
// Register: zx26 : bits
// Register: zx27 : bits
// Register: zx28 : bits
// Register: zx29 : bits
// Register: zx30 : bits
// Register: zx31 : bits

set xpr_general : register_class(rf_xpr);
set xpr_all;
set xpr_all += xpr_general, x_0, x_0_alias;

// Sail mappings converted to Codal elements:
// Mapping: reg_abi_name_raw_forwards -> converted to Codal element definitions
// Mapping: reg_abi_name_raw_forwards_infallible -> converted to Codal element definitions
// Mapping: xreg_full_write_callback -> converted to Codal element definitions
// Mapping: regval_from_reg -> converted to Codal element definitions
// Mapping: regval_into_reg -> converted to Codal element definitions
// Mapping: reg_name_forwards -> converted to Codal element definitions
// Mapping: reg_name_forwards_infallible -> converted to Codal element definitions
// Mapping: xreg_write_callback -> converted to Codal element definitions
// Mapping: initialize_registers -> converted to Codal element definitions

element x0
{
    assembly{STRINGIZE(x0)};
    binary  {0:bit[5]};
    return{0};
};

element x0_alias : assembler_alias(x0)
{
    assembly { "zero" };
    binary { 0:bit[5] };
};
DEF_REG_ALIAS(1, "ra")       // x1
DEF_REG_ALIAS(2, "sp")       // x2
DEF_REG_ALIAS(3, "gp")       // x3
DEF_REG_ALIAS(4, "tp")       // x4
DEF_REG_ALIAS(5, "t0")       // x5
DEF_REG_ALIAS(6, "t1")       // x6
DEF_REG_ALIAS(7, "t2")       // x7
DEF_REG_ALIAS(8, "fp")       // x8
DEF_REG_ALIAS(9, "s1")       // x9
DEF_REG_ALIAS(10, "a0")       // x10
DEF_REG_ALIAS(11, "a1")       // x11
DEF_REG_ALIAS(12, "a2")       // x12
DEF_REG_ALIAS(13, "a3")       // x13
DEF_REG_ALIAS(14, "a4")       // x14
DEF_REG_ALIAS(15, "a5")       // x15
DEF_REG_ALIAS(16, "a6")       // x16
DEF_REG_ALIAS(17, "a7")       // x17
DEF_REG_ALIAS(18, "s2")       // x18
DEF_REG_ALIAS(19, "s3")       // x19
DEF_REG_ALIAS(20, "s4")       // x20
DEF_REG_ALIAS(21, "s5")       // x21
DEF_REG_ALIAS(22, "s6")       // x22
DEF_REG_ALIAS(23, "s7")       // x23
DEF_REG_ALIAS(24, "s8")       // x24
DEF_REG_ALIAS(25, "s9")       // x25
DEF_REG_ALIAS(26, "s10")       // x26
DEF_REG_ALIAS(27, "s11")       // x27
DEF_REG_ALIAS(28, "t3")       // x28
DEF_REG_ALIAS(29, "t4")       // x29
DEF_REG_ALIAS(30, "t5")       // x30
DEF_REG_ALIAS(31, "t6")       // x31

set xpr_general : register_class(rf_xpr);
set xpr_all;
set xpr_all += xpr_general, x_0, x_0_alias;

// Instructions that support an immediate operand, require the definitaion of immediate elements

element uimm5       // unsigned 5-bit immediate
{
    unsigned attribute bit[IMM5_W] value;

    assembly {value};
    binary {value};

    return {value};
};

element simm12       // signed 12-bit immediate
{
    signed attribute bit[IMM12_W] value;

    assembly {value};
    binary {value};

    return {value};
};

element uimm20       // unsigned 20-bit immediate
{
    unsigned attribute bit[IMM20_W] value;

    assembly {value};
    binary {value};

    return {value};
};

///////////////////////////////////////////////////////////////////////////////
//                     relative address operands
/////////////////////////////////////////////////////////////////////////////

element relative_addr12
{
    signed attribute bit[12] addr12
    {
        label = true;
        encoding = (addr13 - current_address) >> HALF_W_ALIGN;
        decoding = ((int14)addr13 << HALF_W_ALIGN) + current_address;
    };
    assembly {addr13};
    binary{addr13};
    return{(uint32)addr13 << HALF_W_ALIGN};
};

element relative_addr20
{
    signed attribute bit[20] addr20
    {
        label = true;
        encoding = (addr13 - current_address) >> HALF_W_ALIGN;
        decoding = ((int14)addr13 << HALF_W_ALIGN) + current_address;
    };
    assembly {addr13};
    binary{addr13};
    return{(uint32)addr13 << HALF_W_ALIGN};
};

/* Opcode definitions following RISC-V pattern */
#define NEQ_INT_OPCODE 0x96
#define REG_ABI_NAME_RAW_FORWARDS_OPCODE 0x41
#define REG_ABI_NAME_RAW_FORWARDS_INFALLIBLE_OPCODE 0x37
#define XREG_FULL_WRITE_CALLBACK_OPCODE 0xef
#define REGVAL_FROM_REG_OPCODE 0x15
#define REGVAL_INTO_REG_OPCODE 0x0d
#define RX_OPCODE 0x38
#define REG_NAME_FORWARDS_OPCODE 0x81
#define REG_NAME_FORWARDS_INFALLIBLE_OPCODE 0xda
#define XREG_WRITE_CALLBACK_OPCODE 0xad
#define TO_BITS_OPCODE 0xcf
#define WX_OPCODE 0xdc
#define RX_BITS_OPCODE 0xc1
#define WX_BITS_OPCODE 0x6b
#define EXECUTE_OPCODE 0xd0
#define INITIALIZE_REGISTERS_OPCODE 0x03

/* Function field definitions */
#define FUNC3_NEQ_INT 0x1d
#define FUNC7_NEQ_INT 0x3b
#define FUNC3_REG_ABI_NAME_RAW_FORWARDS 0x93
#define FUNC7_REG_ABI_NAME_RAW_FORWARDS 0xc0
#define FUNC3_REG_ABI_NAME_RAW_FORWARDS_INFALLIBLE 0x55
#define FUNC7_REG_ABI_NAME_RAW_FORWARDS_INFALLIBLE 0x33
#define FUNC3_XREG_FULL_WRITE_CALLBACK 0x11
#define FUNC7_XREG_FULL_WRITE_CALLBACK 0xa3
#define FUNC3_REGVAL_FROM_REG 0xb8
#define FUNC7_REGVAL_FROM_REG 0xb2
#define FUNC3_REGVAL_INTO_REG 0xa0
#define FUNC7_REGVAL_INTO_REG 0x3e
#define FUNC3_RX 0x80
#define FUNC7_RX 0xd1
#define FUNC3_REG_NAME_FORWARDS 0xe4
#define FUNC7_REG_NAME_FORWARDS 0x00
#define FUNC3_REG_NAME_FORWARDS_INFALLIBLE 0xb4
#define FUNC7_REG_NAME_FORWARDS_INFALLIBLE 0x46
#define FUNC3_XREG_WRITE_CALLBACK 0xf7
#define FUNC7_XREG_WRITE_CALLBACK 0xd2
#define FUNC3_TO_BITS 0x46
#define FUNC7_TO_BITS 0x86
#define FUNC3_WX 0xad
#define FUNC7_WX 0xc1
#define FUNC3_RX_BITS 0xfe
#define FUNC7_RX_BITS 0x64
#define FUNC3_WX_BITS 0x77
#define FUNC7_WX_BITS 0xcc
#define FUNC3_EXECUTE 0x78
#define FUNC7_EXECUTE 0x5b
#define FUNC3_INITIALIZE_REGISTERS 0x8e
#define FUNC7_INITIALIZE_REGISTERS 0x06

/* Instruction sets */
set isa = i_neq_int,
    i_reg_abi_name_raw_forwards,
    i_reg_abi_name_raw_forwards_infallible,
    i_xreg_full_write_callback,
    i_regval_from_reg,
    i_regval_into_reg,
    i_rX,
    i_reg_name_forwards,
    i_reg_name_forwards_infallible,
    i_xreg_write_callback,
    i_to_bits,
    i_wX,
    i_rX_bits,
    i_wX_bits,
    i_execute,
    i_initialize_registers;

/* Main ISA set */
set isa = i_neq_int, i_reg_abi_name_raw_forwards, i_reg_abi_name_raw_forwards_infallible, i_xreg_full_write_callback, i_regval_from_reg, i_regval_into_reg, i_rX, i_reg_name_forwards, i_reg_name_forwards_infallible, i_xreg_write_callback, i_to_bits, i_wX, i_rX_bits, i_wX_bits, i_execute, i_initialize_registers;

/* Start section */
start
{
  roots = { isa };
};

// Type definition: abbrev xlenbits

// Type definition: enum rop

// Type definition: abbrev regtype

// Type definition: variant regno

// Type definition: variant regidx

// Type definition: variant exception

// Type definition: variant ast

bits undefined_bitvector(int) = undefined_bitvector;

bool not_bool(bool) = not;

bool eq_int(int, int) = eq_int;

bool neq_int(int, int);

element neq_int
{
  use xpr_all as zx, zy;
  
  assembly { "neq_int" zx, zy };
  
  binary { imm rs1 FUNC3_OPC rd OPCODE_OPC };
  
  semantics
  {
    // neq_int semantics
    // TODO: Implement specific semantics
  };
};

bool eq_bits(bits, bits) = eq_bits;

bits append_64(bits, bits) = append_64;

bits add_bits(bits, bits) = add_bits;

int unsigned(bits) = sail_unsigned;

register zPC: bits {
  
}

void execute(variant_ast);

string reg_abi_name_raw_forwards(bits);

element reg_abi_name_raw_forwards
{
  use xpr_all as zargz3;
  
  assembly { "reg_abi_name_raw_forwards" zargz3 };
  
  binary { imm rd OPCODE_OPC };
  
  semantics
  {
    // reg_abi_name_raw_forwards semantics
    // TODO: Implement specific semantics
  };
};

string reg_abi_name_raw_forwards_infallible(bits);

element reg_abi_name_raw_forwards_infallible
{
  use xpr_all as zargz3;
  
  assembly { "reg_abi_name_raw_forwards_infallible" zargz3 };
  
  binary { imm rd OPCODE_OPC };
  
  semantics
  {
    // reg_abi_name_raw_forwards_infallible semantics
    // TODO: Implement specific semantics
  };
};

void xreg_full_write_callback(string, bits, bits);

element i_xreg_full_write_callback
{
  use xpr_all as zz53zE68, zz53zE67;
  use simm12 as zz53zE69;
  
  assembly { "xreg_full_write_callback" zz53zE67, zz53zE69(zz53zE68) };
  
  binary { zz53zE69 zz53zE68 FUNC3_XREG_FULL_WRITE_CALLBACK zz53zE67 OPCODE_XREG_FULL_WRITE_CALLBACK };
  
  semantics
  {
    uint32 address, result;
    
    address = rf_xpr_read(zz53zE68) + (int32) zz53zE69;
    result = load(opc, address);
    rf_xpr_write(result, zz53zE67);
  };
};

register zx0: bits {
  
}

register zx1: bits {
  
}

register zx2: bits {
  
}

register zx3: bits {
  
}

register zx4: bits {
  
}

register zx5: bits {
  
}

register zx6: bits {
  
}

register zx7: bits {
  
}

register zx8: bits {
  
}

register zx9: bits {
  
}

register zx10: bits {
  
}

register zx11: bits {
  
}

register zx12: bits {
  
}

register zx13: bits {
  
}

register zx14: bits {
  
}

register zx15: bits {
  
}

register zx16: bits {
  
}

register zx17: bits {
  
}

register zx18: bits {
  
}

register zx19: bits {
  
}

register zx20: bits {
  
}

register zx21: bits {
  
}

register zx22: bits {
  
}

register zx23: bits {
  
}

register zx24: bits {
  
}

register zx25: bits {
  
}

register zx26: bits {
  
}

register zx27: bits {
  
}

register zx28: bits {
  
}

register zx29: bits {
  
}

register zx30: bits {
  
}

register zx31: bits {
  
}

bits regval_from_reg(bits);

element regval_from_reg
{
  use xpr_all as zr;
  
  assembly { "regval_from_reg" zr };
  
  binary { imm rd OPCODE_OPC };
  
  semantics
  {
    // regval_from_reg semantics
    // TODO: Implement specific semantics
  };
};

bits regval_into_reg(bits);

element regval_into_reg
{
  use xpr_all as zv;
  
  assembly { "regval_into_reg" zv };
  
  binary { imm rd OPCODE_OPC };
  
  semantics
  {
    // regval_into_reg semantics
    // TODO: Implement specific semantics
  };
};

bits rX(int);

element rX
{
  use xpr_all as zz53zE70;
  
  assembly { "rX" zz53zE70 };
  
  binary { imm rd OPCODE_OPC };
  
  semantics
  {
    // rX semantics
    // TODO: Implement specific semantics
  };
};

string reg_name_forwards(bits);

element reg_name_forwards
{
  use xpr_all as zargz3;
  
  assembly { "reg_name_forwards" zargz3 };
  
  binary { imm rd OPCODE_OPC };
  
  semantics
  {
    // reg_name_forwards semantics
    // TODO: Implement specific semantics
  };
};

string reg_name_forwards_infallible(bits);

element reg_name_forwards_infallible
{
  use xpr_all as zargz3;
  
  assembly { "reg_name_forwards_infallible" zargz3 };
  
  binary { imm rd OPCODE_OPC };
  
  semantics
  {
    // reg_name_forwards_infallible semantics
    // TODO: Implement specific semantics
  };
};

void xreg_write_callback(bits, bits);

element xreg_write_callback
{
  use xpr_all as zreg, zvalue;
  
  assembly { "xreg_write_callback" zreg, zvalue };
  
  binary { imm rs1 FUNC3_OPC rd OPCODE_OPC };
  
  semantics
  {
    // xreg_write_callback semantics
    // TODO: Implement specific semantics
  };
};

bits __raw_GetSlice_int(int, int, int) = get_slice_int;

bits to_bits(int, int);

element to_bits
{
  use xpr_all as zl, zn;
  
  assembly { "to_bits" zl, zn };
  
  binary { imm rs1 FUNC3_OPC rd OPCODE_OPC };
  
  semantics
  {
    // to_bits semantics
    // TODO: Implement specific semantics
  };
};

void wX(int, bits);

element wX
{
  use xpr_all as zz53zE140, zin_v;
  
  assembly { "wX" zz53zE140, zin_v };
  
  binary { imm rs1 FUNC3_OPC rd OPCODE_OPC };
  
  semantics
  {
    // wX semantics
    // TODO: Implement specific semantics
  };
};

bits rX_bits(bits);

element rX_bits
{
  use xpr_all as zz53zE208;
  
  assembly { "rX_bits" zz53zE208 };
  
  binary { imm rd OPCODE_OPC };
  
  semantics
  {
    // rX_bits semantics
    // TODO: Implement specific semantics
  };
};

void wX_bits(bits, bits);

element wX_bits
{
  use xpr_all as zz53zE209, zdata;
  
  assembly { "wX_bits" zz53zE209, zdata };
  
  binary { imm rs1 FUNC3_OPC rd OPCODE_OPC };
  
  semantics
  {
    // wX_bits semantics
    // TODO: Implement specific semantics
  };
};

element execute
{
  use xpr_all as zz53zE210;
  
  assembly { "execute" zz53zE210 };
  
  binary { imm rd OPCODE_OPC };
  
  semantics
  {
    // execute semantics
    // TODO: Implement specific semantics
  };
};

void initialize_registers(void);

element initialize_registers
{
  use xpr_all as zz53zE214;
  
  assembly { "initialize_registers" zz53zE214 };
  
  binary { imm rd OPCODE_OPC };
  
  semantics
  {
    // initialize_registers semantics
    // TODO: Implement specific semantics
  };
};

/* Original SAIL source and JIB definitions available in: tester.jib */
